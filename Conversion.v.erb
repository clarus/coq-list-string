Require Import Coq.Lists.List.
Require Import Coq.NArith.NArith.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Strings.Ascii.
Require Import Coq.Strings.String.
Require Import ErrorHandlers.All.
Require Char.
Require Import LString.

Import ListNotations.
Import LString.

(** Export to a standard string. *)
Fixpoint to_string (s : t) : String.string :=
  match s with
  | [] => String.EmptyString
  | c :: s => String.String c (to_string s)
  end.

(** Import a standard string. See the alias [s]. *)
Fixpoint of_string (s : String.string) : t :=
  match s with
  | String.EmptyString => []
  | String.String c s => c :: of_string s
  end.

(** Alias for [of_string]. *)
Definition s := of_string.

Fixpoint of_N_aux (base : N) (digits : nat) (n : N) : t :=
  match digits with
  | O => []
  | S digits =>
    if N.eqb n 0 then
      []
    else
      Char.of_N (N.modulo n base) :: of_N_aux base digits (N.div n base)
  end.

(** Convert an integer to a string in base [base] with up to [digits] digits. *)
Definition of_N (base : N) (digits : nat) (n : N) : t :=
  if N.eqb n 0 then
    s "0"
  else
    List.rev' (of_N_aux base digits n).

(** Convert an integer to a string in base [base] with up to [digits] digits. *)
Definition of_Z (base : N) (digits : nat) (n : Z) : t :=
  (if Z.leb 0 n then s "" else s "-") ++
  of_N base digits (Z.to_N (Z.abs n)).

Module OfNat.
  Require Import Program.
  Require Import Coq.Arith.Arith.
  Import Arith.

  Lemma of_nat_lemma : forall m n, 1 < m -> ~ n < m -> 0 < n.
    destruct n; destruct m; intros.
    inversion H. exfalso. apply H0. etransitivity. 2: eassumption. repeat constructor.
    inversion H.
    eapply neq_0_lt. congruence.
  Qed.

  <% nat = version[0..2] == "8.4" ? "NPeano" : "Nat" %>

  Program Fixpoint of_nat_aux (base : nat) (_ : 1 < base) (n : nat) {measure n} : t :=
    match <%= nat %>.ltb n base as x return <%= nat %>.ltb n base = x -> t with
      | true => fun _ => [Char.of_N (N.of_nat n)]
      | false => fun pf =>
        let m := <%= nat %>.div n base in
        Char.of_N (N.of_nat (n - base * m)) :: of_nat_aux base _ m
    end eq_refl.
  Next Obligation.
    eapply <%= version[0..2] == "8.4" ? "NPeano." : "" %>Nat.div_lt; auto.
    apply of_nat_lemma with (m := base); trivial.
    intro Hlt.
    assert (Htrue := proj2 (<%= nat %>.ltb_lt _ _) Hlt); congruence.
  Defined.
End OfNat.

(** Convert an integer to a string in base [base]. *)
Definition of_nat (base : nat) (H : 1 < base) (n : nat) : t :=
  List.rev' (OfNat.of_nat_aux base H n).

(** Convert an integer to a string in base 2. *)
Definition of_nat_2 (n : nat) : t.
  refine (of_nat 2 _ n).
  repeat constructor.
Defined.

(** Convert an integer to a string in base 8. *)
Definition of_nat_8 (n : nat) : t.
  refine (of_nat 8 _ n).
  repeat constructor.
Defined.

(** Convert an integer to a string in base 10. *)
Definition of_nat_10 (n : nat) : t.
  refine (of_nat 10 _ n).
  repeat constructor.
Defined.

(** Convert an integer to a string in base 16. *)
Definition of_nat_16 (n : nat) : t.
  refine (of_nat 16 _ n).
  repeat constructor.
Defined.

Fixpoint to_N_aux (base : N) (s : t) : option N :=
  match s with
  | [] => Some 0%N
  | c :: s =>
    let d := Char.to_N c in
    if andb (N.leb 0 d) (N.ltb d base) then
      Option.bind (to_N_aux base s) (fun n =>
      Some (d + base * n)%N)
    else
      None
  end.

(** The integer represented by a string in base `base`. *)
Definition to_N (base : N) (s : t) : option N :=
  to_N_aux base (List.rev' s).
